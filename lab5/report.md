# Звіт з Лабораторної роботи №5: Нормалізація бази даних

**Тема:** Нормалізація бази даних до 3-ї нормальної форми (3NF)

---

## 1. Аналіз поточної схеми та пошук аномалій

У ході аналізу схеми, розробленої в Лабораторній роботі №2, було виявлено таблиці, що потребують нормалізації для усунення надлишковості даних та потенційних аномалій оновлення.

### Проблемна таблиця: `addresses`
Поточна структура:
- `address_id` (PK)
- `customer_id` (FK)
- `street`
- `city`
- `postal_code`
- `country`

**Виявлені проблеми:**
1.  **Надлишковість:** Назви міст (`city`) та країн (`country`) зберігаються як текстові рядки. Якщо 100 клієнтів живуть у Києві, рядок 'Kyiv' дублюється 100 разів.
2.  **Транзитивна залежність:** Поле `country` логічно залежить від поля `city` (якщо ми знаємо місто, ми знаємо країну), а не напряму від `address_id`. Це порушення 3NF.

### Проблемна таблиця: `orders`
Поточна структура: `order_id`, `...`, `total_amount`.

**Виявлені проблеми:**
1.  **Зберігання обчислюваних даних:** Поле `total_amount` є сумою вартості всіх товарів у замовленні (`order_items`). Зберігання цього значення створює ризик аномалії оновлення (якщо зміниться ціна в позиції замовлення, загальна сума стане некоректною).

---

## 2. Функціональні залежності (Functional Dependencies)

Для таблиці `addresses`:
* `address_id` → `street`, `postal_code`, `city`, `country` (Всі поля залежать від ключа).
* `city` → `country` (Транзитивна залежність: неключовий атрибут визначає інший неключовий атрибут).

---

## 3. Покрокова нормалізація

### Крок 1: Перша Нормальна Форма (1NF)
**Вимога:** Усі атрибути мають бути атомарними.
**Аналіз:** Усі таблиці вже знаходяться в 1NF. У нас немає полів, що містять списки значень (наприклад, "tel1, tel2").

### Крок 2: Друга Нормальна Форма (2NF)
**Вимога:** Відсутність часткових залежностей (для складених ключів).
**Аналіз:** Таблиця `order_items` має складений ключ `(order_id, product_id)`. Поля `quantity` та `price_at_purchase` залежать від обох частин ключа. Часткових залежностей немає. Таблиці в 2NF.

### Крок 3: Третя Нормальна Форма (3NF)
**Вимога:** Відсутність транзитивних залежностей.
**Дія:** Ми повинні винести залежність `city` → `country` в окрему таблицю.

**Рішення:**
1.  Створюємо нову таблицю `cities` (`city_id`, `name`, `country`).
2.  У таблиці `addresses` замінюємо текстові поля `city` та `country` на зовнішній ключ `city_id`.

---

## 4. SQL-інструкції для реалізації змін

Нижче наведено SQL-код для перетворення схеми у 3NF.

```sql
-- 1. Створення таблиці-довідника міст
CREATE TABLE cities (
    city_id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    country VARCHAR(50) NOT NULL,
    UNIQUE (name, country) -- Уникнення дублікатів
);

-- 2. Наповнення містами (на основі існуючих даних)
INSERT INTO cities (name, country)
SELECT DISTINCT city, country FROM addresses;

-- 3. Модифікація таблиці адрес (ALTER TABLE)
-- Додаємо колонку для зовнішнього ключа
ALTER TABLE addresses ADD COLUMN city_id INTEGER;

-- Оновлюємо посилання на ID міст
UPDATE addresses a
SET city_id = c.city_id
FROM cities c
WHERE a.city = c.name AND a.country = c.country;

-- Робимо колонку обов'язковою та додаємо зовнішній ключ
ALTER TABLE addresses 
    ALTER COLUMN city_id SET NOT NULL,
    ADD CONSTRAINT fk_cities FOREIGN KEY (city_id) REFERENCES cities(city_id);

-- Видаляємо старі текстові колонки (нормалізація завершена)
ALTER TABLE addresses DROP COLUMN city;
ALTER TABLE addresses DROP COLUMN country;

-- 4. Видалення надлишкового поля в замовленнях
ALTER TABLE orders DROP COLUMN total_amount;